From a6055308069c29d54932d611c4ca539fc979720e Mon Sep 17 00:00:00 2001
From: Vadim Pasternak <vadimp@nvidia.com>
Date: Sun, 9 Jan 2022 16:35:56 +0200
Subject: [PATCH mlxsw/net-next 1/1] TMP: Debug

---
 drivers/net/ethernet/mellanox/mlxsw/core.c    |  16 +--
 .../net/ethernet/mellanox/mlxsw/core_env.c    | 123 ++++++++++++++++--
 .../net/ethernet/mellanox/mlxsw/core_env.h    |   3 +-
 drivers/net/ethernet/mellanox/mlxsw/minimal.c |  13 +-
 drivers/net/ethernet/mellanox/mlxsw/reg.h     |  54 ++++----
 .../mellanox/mlxsw/spectrum_ethtool.c         |   2 +-
 6 files changed, 156 insertions(+), 55 deletions(-)

diff --git a/drivers/net/ethernet/mellanox/mlxsw/core.c b/drivers/net/ethernet/mellanox/mlxsw/core.c
index a26c6d880..68b1ff67b 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/core.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/core.c
@@ -3020,7 +3020,7 @@ int mlxsw_core_module_max_width(struct mlxsw_core *mlxsw_core, u8 module)
 	char pmtm_pl[MLXSW_REG_PMTM_LEN];
 	int err;
 
-	mlxsw_reg_pmtm_pack(pmtm_pl, module);
+	mlxsw_reg_pmtm_pack(pmtm_pl, 0, module);
 	err = mlxsw_reg_query(mlxsw_core, MLXSW_REG(pmtm), pmtm_pl);
 	if (err)
 		return err;
@@ -3029,21 +3029,21 @@ int mlxsw_core_module_max_width(struct mlxsw_core *mlxsw_core, u8 module)
 	/* Here we need to get the module width according to the module type. */
 
 	switch (module_type) {
-	case MLXSW_REG_PMTM_MODULE_TYPE_C2C8X:
+	case MLXSW_REG_PMTM_MODULE_TYPE_CHIP2CHIP8X:
 	case MLXSW_REG_PMTM_MODULE_TYPE_QSFP_DD:
 	case MLXSW_REG_PMTM_MODULE_TYPE_OSFP:
 		return 8;
-	case MLXSW_REG_PMTM_MODULE_TYPE_C2C4X:
-	case MLXSW_REG_PMTM_MODULE_TYPE_BP_4X:
+	case MLXSW_REG_PMTM_MODULE_TYPE_CHIP2CHIP4X:
+	case MLXSW_REG_PMTM_MODULE_TYPE_BACKPLANE_4_LANES:
 	case MLXSW_REG_PMTM_MODULE_TYPE_QSFP:
 		return 4;
-	case MLXSW_REG_PMTM_MODULE_TYPE_C2C2X:
-	case MLXSW_REG_PMTM_MODULE_TYPE_BP_2X:
+	case MLXSW_REG_PMTM_MODULE_TYPE_CHIP2CHIP2X:
+	case MLXSW_REG_PMTM_MODULE_TYPE_BACKPLANE_2_LANES:
 	case MLXSW_REG_PMTM_MODULE_TYPE_SFP_DD:
 	case MLXSW_REG_PMTM_MODULE_TYPE_DSFP:
 		return 2;
-	case MLXSW_REG_PMTM_MODULE_TYPE_C2C1X:
-	case MLXSW_REG_PMTM_MODULE_TYPE_BP_1X:
+	case MLXSW_REG_PMTM_MODULE_TYPE_CHIP2CHIP1X:
+	case MLXSW_REG_PMTM_MODULE_TYPE_BACKPLANE_SINGLE_LANE:
 	case MLXSW_REG_PMTM_MODULE_TYPE_SFP:
 		return 1;
 	default:
diff --git a/drivers/net/ethernet/mellanox/mlxsw/core_env.c b/drivers/net/ethernet/mellanox/mlxsw/core_env.c
index 98f7cf672..f6a71396b 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/core_env.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/core_env.c
@@ -18,6 +18,7 @@ struct mlxsw_env_module_info {
 	int num_ports_mapped;
 	int num_ports_up;
 	enum ethtool_module_power_mode_policy power_mode_policy;
+	enum mlxsw_reg_pmtm_module_type module_type;
 };
 
 struct mlxsw_env_module_line_cards {
@@ -33,6 +34,46 @@ struct mlxsw_env {
 	struct mlxsw_env_module_line_cards *line_cards[];
 };
 
+static struct
+mlxsw_env_module_info *mlxsw_env_module_info_get(struct mlxsw_core *mlxsw_core,
+						 u8 slot_index, u8 module)
+{
+	struct mlxsw_env *mlxsw_env = mlxsw_core_env(mlxsw_core);
+
+	return &mlxsw_env->line_cards[slot_index]->module_info[module];
+}
+
+static int __mlxsw_env_validate_module_type(struct mlxsw_core *core,
+					    u8 slot_index, u8 module)
+{
+	struct mlxsw_env_module_info *module_info;
+	int err;
+
+	module_info = mlxsw_env_module_info_get(core, slot_index, module);
+	switch (module_info->module_type) {
+	case MLXSW_REG_PMTM_MODULE_TYPE_TWISTED_PAIR:
+		err = -EINVAL;
+		break;
+	default:
+		err = 0;
+	}
+
+	return err;
+}
+
+static int mlxsw_env_validate_module_type(struct mlxsw_core *core,
+					  u8 slot_index, u8 module)
+{
+	struct mlxsw_env *mlxsw_env = mlxsw_core_env(core);
+	int err;
+
+	mutex_lock(&mlxsw_env->line_cards_lock);
+	err = __mlxsw_env_validate_module_type(core, slot_index, module);
+	mutex_unlock(&mlxsw_env->line_cards_lock);
+
+	return err;
+}
+
 static int
 mlxsw_env_validate_cable_ident(struct mlxsw_core *core, u8 slot_index, int id,
 			       bool *qsfp, bool *cmis)
@@ -42,6 +83,10 @@ mlxsw_env_validate_cable_ident(struct mlxsw_core *core, u8 slot_index, int id,
 	u8 ident;
 	int err;
 
+	err = mlxsw_env_validate_module_type(core, slot_index, id);
+	if (err)
+		return err;
+
 	mlxsw_reg_mcia_pack(mcia_pl, slot_index, id, 0,
 			    MLXSW_REG_MCIA_PAGE0_LO_OFF, 0, 1,
 			    MLXSW_REG_MCIA_I2C_ADDR_LOW);
@@ -218,7 +263,8 @@ mlxsw_env_module_temp_thresholds_get(struct mlxsw_core *core, u8 slot_index,
 	return 0;
 }
 
-int mlxsw_env_get_module_info(struct mlxsw_core *mlxsw_core, u8 slot_index,
+int mlxsw_env_get_module_info(struct net_device *netdev,
+			      struct mlxsw_core *mlxsw_core, u8 slot_index,
 			      int module, struct ethtool_modinfo *modinfo)
 {
 	u8 module_info[MLXSW_REG_MCIA_EEPROM_MODULE_INFO_SIZE];
@@ -227,6 +273,13 @@ int mlxsw_env_get_module_info(struct mlxsw_core *mlxsw_core, u8 slot_index,
 	unsigned int read_size;
 	int err;
 
+	err = mlxsw_env_validate_module_type(mlxsw_core, slot_index, module);
+	if (err) {
+		netdev_err(netdev,
+			   "EEPROM is not equipped on port module type");
+		return err;
+	}
+
 	err = mlxsw_env_query_module_eeprom(mlxsw_core, slot_index, module, 0,
 					    offset, module_info, false,
 					    &read_size);
@@ -374,15 +427,22 @@ mlxsw_env_get_module_eeprom_by_page(struct mlxsw_core *mlxsw_core,
 {
 	u32 bytes_read = 0;
 	u16 device_addr;
+	int err;
 
 	/* Offset cannot be larger than 2 * ETH_MODULE_EEPROM_PAGE_LEN */
 	device_addr = page->offset;
 
+	err = mlxsw_env_validate_module_type(mlxsw_core, slot_index,
+					     module);
+	if (err) {
+		NL_SET_ERR_MSG_MOD(extack, "EEPROM is not equipped on port module type");
+		return err;
+	}
+
 	while (bytes_read < page->length) {
 		char mcia_pl[MLXSW_REG_MCIA_LEN];
 		char *eeprom_tmp;
 		u8 size;
-		int err;
 
 		size = min_t(u8, page->length - bytes_read,
 			     MLXSW_REG_MCIA_EEPROM_SIZE);
@@ -411,15 +471,6 @@ mlxsw_env_get_module_eeprom_by_page(struct mlxsw_core *mlxsw_core,
 }
 EXPORT_SYMBOL(mlxsw_env_get_module_eeprom_by_page);
 
-static struct
-mlxsw_env_module_info *mlxsw_env_module_info_get(struct mlxsw_core *mlxsw_core,
-						 u8 slot_index, u8 module)
-{
-	struct mlxsw_env *mlxsw_env = mlxsw_core_env(mlxsw_core);
-
-	return &mlxsw_env->line_cards[slot_index]->module_info[module];
-}
-
 static int mlxsw_env_module_reset(struct mlxsw_core *mlxsw_core, u8 slot_index,
 				  u8 module)
 {
@@ -446,6 +497,12 @@ int mlxsw_env_reset_module(struct net_device *netdev,
 
 	mutex_lock(&mlxsw_env->line_cards_lock);
 
+	err = __mlxsw_env_validate_module_type(mlxsw_core, slot_index, module);
+	if (err) {
+		netdev_err(netdev, "Reset module is not supported on port module type\n");
+		goto out;
+	}
+
 	module_info = mlxsw_env_module_info_get(mlxsw_core, slot_index, module);
 	if (module_info->num_ports_up) {
 		netdev_err(netdev, "Cannot reset module when ports using it are administratively up\n");
@@ -488,6 +545,12 @@ mlxsw_env_get_module_power_mode(struct mlxsw_core *mlxsw_core, u8 slot_index,
 
 	mutex_lock(&mlxsw_env->line_cards_lock);
 
+	err = __mlxsw_env_validate_module_type(mlxsw_core, slot_index, module);
+	if (err) {
+		NL_SET_ERR_MSG_MOD(extack, "Power mode is not supported on port module type");
+		goto out;
+	}
+
 	module_info = mlxsw_env_module_info_get(mlxsw_core, slot_index, module);
 	params->policy = module_info->power_mode_policy;
 
@@ -602,6 +665,13 @@ mlxsw_env_set_module_power_mode(struct mlxsw_core *mlxsw_core, u8 slot_index,
 
 	mutex_lock(&mlxsw_env->line_cards_lock);
 
+	err = __mlxsw_env_validate_module_type(mlxsw_core, slot_index, module);
+	if (err) {
+		NL_SET_ERR_MSG_MOD(extack,
+				   "Power mode set is not supported on port module type");
+		goto out;
+	}
+
 	module_info = mlxsw_env_module_info_get(mlxsw_core, slot_index, module);
 	if (module_info->power_mode_policy == policy)
 		goto out;
@@ -1095,18 +1165,39 @@ void mlxsw_env_module_port_down(struct mlxsw_core *mlxsw_core, u8 slot_index,
 }
 EXPORT_SYMBOL(mlxsw_env_module_port_down);
 
+static int
+mlxsw_env_module_type_set(struct mlxsw_env_module_info *module_info,
+			  struct mlxsw_core *mlxsw_core,
+			  u8 slot_index, u8 module)
+{
+	char pmtm_pl[MLXSW_REG_PMTM_LEN];
+	int err;
+
+	mlxsw_reg_pmtm_pack(pmtm_pl, slot_index, module);
+
+	err = mlxsw_reg_query(mlxsw_core, MLXSW_REG(pmtm), pmtm_pl);
+	if (err)
+		return err;
+
+	module_info->module_type = mlxsw_reg_pmtm_module_type_get(pmtm_pl);
+	return 0;
+}
+
 static int mlxsw_env_line_cards_alloc(struct mlxsw_env *env)
 {
 	struct mlxsw_env_module_info *module_info;
 	int i, j;
+	int err;
 
 	for (i = 0; i < env->num_of_slots; i++) {
 		env->line_cards[i] = kzalloc(struct_size(env->line_cards[i],
 							 module_info,
 							 env->max_module_count),
 							 GFP_KERNEL);
-		if (!env->line_cards[i])
+		if (!env->line_cards[i]) {
+			err = -ENOMEM;
 			goto kzalloc_err;
+		}
 
 		/* Firmware defaults to high power mode policy where modules
 		 * are transitioned to high power mode following plug-in.
@@ -1115,15 +1206,21 @@ static int mlxsw_env_line_cards_alloc(struct mlxsw_env *env)
 			module_info = &env->line_cards[i]->module_info[j];
 			module_info->power_mode_policy =
 					ETHTOOL_MODULE_POWER_MODE_POLICY_HIGH;
+			err = mlxsw_env_module_type_set(module_info,
+							env->core, i, j);
+			if (err)
+				goto module_type_set_err;
 		}
 	}
 
 	return 0;
 
+module_type_set_err:
+	kfree(env->line_cards[i]);
 kzalloc_err:
 	for (i--; i >= 0; i--)
 		kfree(env->line_cards[i]);
-	return -ENOMEM;
+	return err;
 }
 
 static void mlxsw_env_line_cards_free(struct mlxsw_env *env)
diff --git a/drivers/net/ethernet/mellanox/mlxsw/core_env.h b/drivers/net/ethernet/mellanox/mlxsw/core_env.h
index 336c9ee57..dd6651d38 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/core_env.h
+++ b/drivers/net/ethernet/mellanox/mlxsw/core_env.h
@@ -18,7 +18,8 @@ int mlxsw_env_module_temp_thresholds_get(struct mlxsw_core *core,
 					 u8 slot_index, int module, int off,
 					 int *temp);
 
-int mlxsw_env_get_module_info(struct mlxsw_core *mlxsw_core, u8 slot_index,
+int mlxsw_env_get_module_info(struct net_device *netdev,
+			      struct mlxsw_core *mlxsw_core, u8 slot_index,
 			      int module, struct ethtool_modinfo *modinfo);
 
 int mlxsw_env_get_module_eeprom(struct net_device *netdev,
diff --git a/drivers/net/ethernet/mellanox/mlxsw/minimal.c b/drivers/net/ethernet/mellanox/mlxsw/minimal.c
index 2c54aef1e..063e53c3a 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/minimal.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/minimal.c
@@ -128,7 +128,7 @@ static int mlxsw_m_get_module_info(struct net_device *netdev,
 	struct mlxsw_m_port *mlxsw_m_port = netdev_priv(netdev);
 	struct mlxsw_core *core = mlxsw_m_port->mlxsw_m->core;
 
-	return mlxsw_env_get_module_info(core, mlxsw_m_port->slot_index,
+	return mlxsw_env_get_module_info(netdev, core, mlxsw_m_port->slot_index,
 					 mlxsw_m_port->module, modinfo);
 }
 
@@ -246,7 +246,7 @@ mlxsw_m_port_create(struct mlxsw_m *mlxsw_m, u8 slot_index, u16 local_port,
 	module_offset = slot_index ? (slot_index - 1) *
 			mlxsw_m->max_module_count : 0;
 
-	err = mlxsw_core_port_init(mlxsw_m->core, local_port + module_offset, 0,
+	err = mlxsw_core_port_init(mlxsw_m->core, local_port /*+ module_offset*/, slot_index,
 				   module + 1 + module_offset, false, 0, false,
 				   0, mlxsw_m->base_mac,
 				   sizeof(mlxsw_m->base_mac));
@@ -362,6 +362,7 @@ static int mlxsw_m_ports_create(struct mlxsw_m *mlxsw_m, u8 slot_index)
 {
 	struct mlxsw_m_port_mapping *port_mapping;
 	char mgpir_pl[MLXSW_REG_MGPIR_LEN];
+	u8 module_offset;
 	int i, err;
 
 	mlxsw_reg_mgpir_pack(mgpir_pl, slot_index);
@@ -376,9 +377,15 @@ static int mlxsw_m_ports_create(struct mlxsw_m *mlxsw_m, u8 slot_index)
 		return 0;
 
 	mlxsw_m->line_cards[slot_index]->max_ports += 1;
+
+	module_offset = slot_index ? (slot_index - 1) *
+			mlxsw_m->max_module_count : 0;
+
+
 	/* Fill out module to local port mapping array */
 	for (i = 1; i < mlxsw_m->line_cards[slot_index]->max_ports; i++) {
-		err = mlxsw_m_port_module_map(mlxsw_m, slot_index, i, i - 1);
+		err = mlxsw_m_port_module_map(mlxsw_m, slot_index, i +
+					      module_offset, i - 1);
 		if (err)
 			goto err_module_to_port_map;
 	}
diff --git a/drivers/net/ethernet/mellanox/mlxsw/reg.h b/drivers/net/ethernet/mellanox/mlxsw/reg.h
index ce3842ed8..78f95e58e 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/reg.h
+++ b/drivers/net/ethernet/mellanox/mlxsw/reg.h
@@ -5738,14 +5738,21 @@ static inline void mlxsw_reg_pmmp_pack(char *payload, u8 slot_index, u8 module)
 }
 
 /* PMTM - Port Module Type Mapping Register
- * ----------------------------------------
- * The PMTM allows query or configuration of module types.
+ * -------------------------------------------------
+ * The PMTM register allows query or configuration of module types.
+ * The register can only be set when the module is disabled by PMAOS register
  */
 #define MLXSW_REG_PMTM_ID 0x5067
 #define MLXSW_REG_PMTM_LEN 0x10
 
 MLXSW_REG_DEFINE(pmtm, MLXSW_REG_PMTM_ID, MLXSW_REG_PMTM_LEN);
 
+/* reg_pmtm_slot_index
+ * Slot index.
+ * Access: Index
+ */
+MLXSW_ITEM32(reg, pmtm, slot_index, 0x00, 24, 4);
+
 /* reg_pmtm_module
  * Module number.
  * Access: Index
@@ -5753,43 +5760,32 @@ MLXSW_REG_DEFINE(pmtm, MLXSW_REG_PMTM_ID, MLXSW_REG_PMTM_LEN);
 MLXSW_ITEM32(reg, pmtm, module, 0x00, 16, 8);
 
 enum mlxsw_reg_pmtm_module_type {
-	/* Backplane with 4 lanes */
-	MLXSW_REG_PMTM_MODULE_TYPE_BP_4X,
-	/* QSFP */
-	MLXSW_REG_PMTM_MODULE_TYPE_QSFP,
-	/* SFP */
-	MLXSW_REG_PMTM_MODULE_TYPE_SFP,
-	/* Backplane with single lane */
-	MLXSW_REG_PMTM_MODULE_TYPE_BP_1X = 4,
-	/* Backplane with two lane */
-	MLXSW_REG_PMTM_MODULE_TYPE_BP_2X = 8,
-	/* Chip2Chip4x */
-	MLXSW_REG_PMTM_MODULE_TYPE_C2C4X = 10,
-	/* Chip2Chip2x */
-	MLXSW_REG_PMTM_MODULE_TYPE_C2C2X,
-	/* Chip2Chip1x */
-	MLXSW_REG_PMTM_MODULE_TYPE_C2C1X,
-	/* QSFP-DD */
+	MLXSW_REG_PMTM_MODULE_TYPE_BACKPLANE_4_LANES = 0,
+	MLXSW_REG_PMTM_MODULE_TYPE_QSFP = 1,
+	MLXSW_REG_PMTM_MODULE_TYPE_SFP = 2,
+	MLXSW_REG_PMTM_MODULE_TYPE_BACKPLANE_SINGLE_LANE = 4,
+	MLXSW_REG_PMTM_MODULE_TYPE_BACKPLANE_2_LANES = 8,
+	MLXSW_REG_PMTM_MODULE_TYPE_CHIP2CHIP4X = 10,
+	MLXSW_REG_PMTM_MODULE_TYPE_CHIP2CHIP2X = 11,
+	MLXSW_REG_PMTM_MODULE_TYPE_CHIP2CHIP1X = 12,
 	MLXSW_REG_PMTM_MODULE_TYPE_QSFP_DD = 14,
-	/* OSFP */
-	MLXSW_REG_PMTM_MODULE_TYPE_OSFP,
-	/* SFP-DD */
-	MLXSW_REG_PMTM_MODULE_TYPE_SFP_DD,
-	/* DSFP */
-	MLXSW_REG_PMTM_MODULE_TYPE_DSFP,
-	/* Chip2Chip8x */
-	MLXSW_REG_PMTM_MODULE_TYPE_C2C8X,
+	MLXSW_REG_PMTM_MODULE_TYPE_OSFP = 15,
+	MLXSW_REG_PMTM_MODULE_TYPE_SFP_DD = 16,
+	MLXSW_REG_PMTM_MODULE_TYPE_DSFP = 17,
+	MLXSW_REG_PMTM_MODULE_TYPE_CHIP2CHIP8X = 18,
+	MLXSW_REG_PMTM_MODULE_TYPE_TWISTED_PAIR = 19,
 };
 
 /* reg_pmtm_module_type
  * Module type.
  * Access: RW
  */
-MLXSW_ITEM32(reg, pmtm, module_type, 0x04, 0, 4);
+MLXSW_ITEM32(reg, pmtm, module_type, 0x04, 0, 5);
 
-static inline void mlxsw_reg_pmtm_pack(char *payload, u8 module)
+static inline void mlxsw_reg_pmtm_pack(char *payload, u8 slot_index, u8 module)
 {
 	MLXSW_REG_ZERO(pmtm, payload);
+	mlxsw_reg_pmtm_slot_index_set(payload, slot_index);
 	mlxsw_reg_pmtm_module_set(payload, module);
 }
 
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum_ethtool.c b/drivers/net/ethernet/mellanox/mlxsw/spectrum_ethtool.c
index c9298b236..b683b31e4 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_ethtool.c
@@ -1032,7 +1032,7 @@ static int mlxsw_sp_get_module_info(struct net_device *netdev,
 	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;
 	int err;
 
-	err = mlxsw_env_get_module_info(mlxsw_sp->core, 0,
+	err = mlxsw_env_get_module_info(netdev, mlxsw_sp->core, 0,
 					mlxsw_sp_port->mapping.module,
 					modinfo);
 
-- 
2.20.1

